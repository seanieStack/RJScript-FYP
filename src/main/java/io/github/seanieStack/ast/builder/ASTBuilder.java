package io.github.seanieStack.ast.builder;

import io.github.seanieStack.ast.core.ASTNode;
import io.github.seanieStack.ast.expressions.*;
import io.github.seanieStack.ast.statements.*;
import io.github.seanieStack.ast.structural.BlockNode;
import io.github.seanieStack.ast.structural.FunctionDeclarationNode;
import io.github.seanieStack.ast.structural.ProgramNode;
import io.github.seanieStack.parser.RJScriptBaseVisitor;
import io.github.seanieStack.parser.RJScriptParser;
import java.util.ArrayList;
import java.util.List;

/**
 * Takes the parse tree generated by ANTLR and generates an Abstract Syntax Tree (AST)
 * This class extends the ANTLR base visitor and converts the parse tree into a more
 * readable / manageable AST representation.
 */
public class ASTBuilder extends RJScriptBaseVisitor<ASTNode> {

    /**
     * Visits a program context and builds a ProgramNode containing all statements.
     *
     * @param ctx the program context from the parse tree
     * @return a ProgramNode containing all statements in the program
     */
    @Override
    public ASTNode visitProgram(RJScriptParser.ProgramContext ctx) {
        return new ProgramNode(ctx.statement().stream().map(this::visit).toList());
    }

    /**
     * Visits a variable declaration context and builds a VarDeclarationNode.
     *
     * @param ctx the variable declaration context from the parse tree
     * @return a VarDeclarationNode containing the identifier and initialization expression
     */
    @Override
    public ASTNode visitVarDeclaration(RJScriptParser.VarDeclarationContext ctx) {
        return new VarDeclarationNode(
                ctx.IDENTIFIER().getText(),
                visit(ctx.expression())
        );
    }

    /**
     * Visits a variable assignment context and builds a VarAssignmentNode.
     *
     * @param ctx the variable assignment context from the parse tree
     * @return a VarAssignmentNode containing the identifier and new value expression
     */
    @Override
    public ASTNode visitVarAssignment(RJScriptParser.VarAssignmentContext ctx){
        return new VarAssignmentNode(
                ctx.IDENTIFIER().getText(),
                visit(ctx.expression())
        );
    }

    /**
     * Visits an indexed assignment context and builds an IndexedAssignmentNode.
     * Handles multi-dimensional array assignments like arr[0][1] = value.
     *
     * @param ctx the indexed assignment context from the parse tree
     * @return an IndexedAssignmentNode containing the identifier, indices, and value
     */
    @Override
    public ASTNode visitIndexedAssignment(RJScriptParser.IndexedAssignmentContext ctx) {
        String identifier = ctx.IDENTIFIER().getText();

        // All expressions except the last one are indices, the last is the value
        List<RJScriptParser.ExpressionContext> allExpressions = ctx.expression();
        List<ASTNode> indices = new ArrayList<>();

        // All but the last expression are indices
        for (int i = 0; i < allExpressions.size() - 1; i++) {
            indices.add(visit(allExpressions.get(i)));
        }

        // The last expression is the value being assigned
        ASTNode value = visit(allExpressions.getLast());

        return new IndexedAssignmentNode(identifier, indices, value);
    }

    /**
     * Visits an if statement context and builds an IfStatementNode including
     * the condition, then block, all else-if clauses, and optional else block.
     *
     * @param ctx the if statement context from the parse tree
     * @return an IfStatementNode containing all conditional branches
     */
    @Override
    public ASTNode visitIfStatement(RJScriptParser.IfStatementContext ctx) {
        ASTNode condition = visit(ctx.expression());
        BlockNode thenBlock = (BlockNode) visit(ctx.block());

        List<IfStatementNode.ElseIfClause> elseIfClauses = new ArrayList<>();
        for (RJScriptParser.ElseIfStatementContext elseIfCtx : ctx.elseIfStatement()) {
            ASTNode elseIfCondition = visit(elseIfCtx.expression());
            BlockNode elseIfBlock = (BlockNode) visit(elseIfCtx.block());
            elseIfClauses.add(new IfStatementNode.ElseIfClause(elseIfCondition, elseIfBlock));
        }

        BlockNode elseBlock = null;
        if (ctx.elseStatement() != null) {
            elseBlock = (BlockNode) visit(ctx.elseStatement().block());
        }

        return new IfStatementNode(condition, thenBlock, elseIfClauses, elseBlock);
    }

    /**
     * Visits a while statement context and builds a WhileStatementNode including
     * the condition and the body.
     *
     * @param ctx the while statement context from the parse tree
     * @return a WhileStatementNode containing the loop condition and body
     */
    @Override
    public ASTNode visitWhileStatement(RJScriptParser.WhileStatementContext ctx) {
        ASTNode condition = visit(ctx.expression());
        BlockNode body = (BlockNode) visit(ctx.block());
        return new WhileStatementNode(condition, body);
    }

    /**
     * Visits a for statement context and builds a ForStatementNode with
     * initialization, condition, update, and body.
     *
     * @param ctx the for statement context from the parse tree
     * @return a ForStatementNode containing all loop components
     */
    @Override
    public ASTNode visitForStatement(RJScriptParser.ForStatementContext ctx) {
        ASTNode initialization = visit(ctx.forInit());
        ASTNode condition = visit(ctx.expression());
        ASTNode update = visit(ctx.forUpdate());
        BlockNode body = (BlockNode) visit(ctx.block());
        return new ForStatementNode(initialization, condition, update, body);
    }

    /**
     * Visits a for loop initialization context and builds either a VarDeclarationNode
     * or VarAssignmentNode depending on whether 'let' keyword is present.
     *
     * @param ctx the for initialization context from the parse tree
     * @return a VarDeclarationNode if using 'let', otherwise a VarAssignmentNode
     */
    @Override
    public ASTNode visitForInit(RJScriptParser.ForInitContext ctx) {
        if (ctx.LET() != null) {
            return new VarDeclarationNode(
                    ctx.IDENTIFIER().getText(),
                    visit(ctx.expression())
            );
        } else {
            return new VarAssignmentNode(
                    ctx.IDENTIFIER().getText(),
                    visit(ctx.expression())
            );
        }
    }

    /**
     * Visits a for loop update context and builds a VarAssignmentNode.
     *
     * @param ctx the for update context from the parse tree
     * @return a VarAssignmentNode representing the loop update expression
     */
    @Override
    public ASTNode visitForUpdate(RJScriptParser.ForUpdateContext ctx) {
        return new VarAssignmentNode(
                ctx.IDENTIFIER().getText(),
                visit(ctx.expression())
        );
    }

    /**
     * Visits a function declaration context and builds a FunctionDeclarationNode
     * with the function name, parameter list, and body.
     *
     * @param ctx the function declaration context from the parse tree
     * @return a FunctionDeclarationNode containing the function definition
     */
    @Override
    public ASTNode visitFunctionDeclaration(RJScriptParser.FunctionDeclarationContext ctx) {
        String name = ctx.IDENTIFIER().getText();

        List<String> parameters = new ArrayList<>();
        if (ctx.parameterList() != null) {
            for (var identifier : ctx.parameterList().IDENTIFIER()) {
                parameters.add(identifier.getText());
            }
        }

        BlockNode body = (BlockNode) visit(ctx.block());

        return new FunctionDeclarationNode(name, parameters, body);
    }

    /**
     * Visits a return statement context and builds a ReturnStatementNode.
     *
     * @param ctx the return statement context from the parse tree
     * @return a ReturnStatementNode containing the return expression
     */
    @Override
    public ASTNode visitReturnStatement(RJScriptParser.ReturnStatementContext ctx) {
        return new ReturnStatementNode(visit(ctx.expression()));
    }

    /**
     * Visits a block context and builds a BlockNode containing all statements
     * within the block.
     *
     * @param ctx the block context from the parse tree
     * @return a BlockNode containing all statements in the block
     */
    @Override
    public ASTNode visitBlock(RJScriptParser.BlockContext ctx) {
        return new BlockNode(ctx.statement().stream().map(this::visit).toList());
    }

    /**
     * Visits an expression statement context and builds an ExpressionStatementNode.
     *
     * @param ctx the expression statement context from the parse tree
     * @return an ExpressionStatementNode wrapping the expression
     */
    @Override
    public ASTNode visitExpressionStatement(RJScriptParser.ExpressionStatementContext ctx) {
        return new ExpressionStatementNode(visit(ctx.expression()));
    }

    /**
     * Visits an expression context and delegates to the comparison level of
     * the expression hierarchy.
     *
     * @param ctx the expression context from the parse tree
     * @return the AST node representing the expression
     */
    @Override
    public ASTNode visitExpression(RJScriptParser.ExpressionContext ctx) {
        return visit(ctx.comparison());
    }

    /**
     * Visits a comparison context and builds a BinaryOpNode for comparison
     * operators, or returns the additive expression if no comparison operator is present.
     *
     * @param ctx the comparison context from the parse tree
     * @return a BinaryOpNode for comparisons, or the left operand if no comparison
     */
    @Override
    public ASTNode visitComparison(RJScriptParser.ComparisonContext ctx) {
        ASTNode left = visit(ctx.additive(0));

        if (ctx.additive().size() > 1) {
            String operator = ctx.getChild(1).getText();
            ASTNode right = visit(ctx.additive(1));

            BinaryOpNode.Operator op = switch (operator) {
                case "<" -> BinaryOpNode.Operator.LESS_THAN;
                case ">" -> BinaryOpNode.Operator.GREATER_THAN;
                case "<=" -> BinaryOpNode.Operator.LESS_EQUAL;
                case ">=" -> BinaryOpNode.Operator.GREATER_EQUAL;
                case "==" -> BinaryOpNode.Operator.EQUAL;
                case "!=" -> BinaryOpNode.Operator.NOT_EQUAL;
                default -> throw new RuntimeException("Unknown comparison operator: " + operator);
            };

            return new BinaryOpNode(op, left, right);
        }

        return left;
    }

    /**
     * Visits an additive context and builds a chain of BinaryOpNodes for addition
     * and subtraction operations. Handles left-associative operators by building
     * the tree from left to right.
     *
     * @param ctx the additive context from the parse tree
     * @return a BinaryOpNode tree representing the additive expression, or a single operand if no operators
     */
    @Override
    public ASTNode visitAdditive(RJScriptParser.AdditiveContext ctx) {
        ASTNode result = visit(ctx.multiplicative(0));

        // Process operators left-to-right to ensure left-associativity (e.g., a - b + c means (a - b) + c)
        for (int i = 0; i < ctx.multiplicative().size() - 1; i++) {
            // Use 2 * i + 1 because children alternate: operand, operator, operand, operator, ...
            String operator = ctx.getChild(2 * i + 1).getText();
            ASTNode right = visit(ctx.multiplicative(i + 1));

            BinaryOpNode.Operator op = operator.equals("+") ?
                    BinaryOpNode.Operator.ADD :
                    BinaryOpNode.Operator.SUBTRACT;

            result = new BinaryOpNode(op, result, right);
        }

        return result;
    }

    /**
     * Visits a multiplicative context and builds a chain of BinaryOpNodes for multiplication
     * and division operations. Handles left-associative operators by building the tree from left to right.
     *
     * @param ctx the multiplicative context from the parse tree
     * @return a BinaryOpNode tree representing the multiplicative expression, or a single operand if no operators
     */
    @Override
    public ASTNode visitMultiplicative(RJScriptParser.MultiplicativeContext ctx) {
        ASTNode result = visit(ctx.unary(0));

        // Process operators left-to-right to ensure left-associativity (e.g., a / b * c means (a / b) * c)
        for (int i = 0; i < ctx.unary().size() - 1; i++) {
            // Use 2 * i + 1 because children alternate: operand, operator, operand, operator, ...
            String operator = ctx.getChild(2 * i + 1).getText();
            ASTNode right = visit(ctx.unary(i + 1));

            BinaryOpNode.Operator op = operator.equals("*") ?
                    BinaryOpNode.Operator.MULTIPLY :
                    BinaryOpNode.Operator.DIVIDE;

            result = new BinaryOpNode(op, result, right);
        }

        return result;
    }

    /**
     * Visits a unary context and builds a UnaryOpNode if a unary operator is present,
     * or delegates to the primary expression if not.
     *
     * @param ctx the unary context from the parse tree
     * @return a UnaryOpNode for negation, or the primary expression if no unary operator
     */
    @Override
    public ASTNode visitUnary(RJScriptParser.UnaryContext ctx) {
        if (ctx.MINUS() != null) {
            ASTNode operand = visit(ctx.unary());
            return new UnaryOpNode(UnaryOpNode.Operator.NEGATE, operand);
        } else {
            return visit(ctx.primary());
        }
    }

    /**
     * Visits a primary context and builds the appropriate AST node for literals,
     * variables, function calls, or parenthesized expressions.
     *
     * @param ctx the primary context from the parse tree
     * @return the AST node representing the primary expression (IntLiteralNode, BoolLiteralNode,
     *         VariableNode, FunctionCallNode, or a parenthesized expression)
     * @throws RuntimeException if the primary expression type is not recognized
     */
    @Override
    public ASTNode visitPrimary(RJScriptParser.PrimaryContext ctx) {
        if (ctx.INT() != null) {
            return new IntLiteralNode(Integer.parseInt(ctx.INT().getText()));
        } else if (ctx.FLOAT() != null) {
            return new FloatLiteralNode(Double.parseDouble((ctx.FLOAT().getText())));
        } else if (ctx.BOOLEAN() != null) {
            return new BoolLiteralNode(Boolean.parseBoolean(ctx.BOOLEAN().getText()));
        } else if (ctx.STRING_LITERAL() != null) {
            String rawText = ctx.STRING_LITERAL().getText();
            String unquotedText = rawText.substring(1, rawText.length() - 1);
            String unescapedText = unescapeString(unquotedText);
            return new StringLiteralNode(unescapedText);
        } else if (ctx.arrayLiteral() != null) {
            return visit(ctx.arrayLiteral());
        } else if (ctx.functionCall() != null) {
            return visit(ctx.functionCall());
        } else if (ctx.indexAccess() != null) {
            return visit(ctx.indexAccess());
        } else if (ctx.IDENTIFIER() != null) {
            return new VariableNode(ctx.IDENTIFIER().getText());
        } else if (ctx.expression() != null) {
            return visit(ctx.expression());
        }
        throw new RuntimeException("Unknown primary expression");
    }

    /**
     * Visits a function call context and builds a FunctionCallNode with the
     * function name and list of argument expressions.
     *
     * @param ctx the function call context from the parse tree
     * @return a FunctionCallNode containing the function name and arguments
     */
    @Override
    public ASTNode visitFunctionCall(RJScriptParser.FunctionCallContext ctx) {
        String name = ctx.IDENTIFIER().getText();

        List<ASTNode> arguments = new ArrayList<>();
        if (ctx.argumentList() != null) {
            for (var expr : ctx.argumentList().expression()) {
                arguments.add(visit(expr));
            }
        }

        return new FunctionCallNode(name, arguments);
    }

    /**
     * Visits an array literal context and builds an ArrayLiteralNode.
     *
     * @param ctx the array literal context from the parse tree
     * @return an ArrayLiteralNode containing all element expressions
     */
    @Override
    public ASTNode visitArrayLiteral(RJScriptParser.ArrayLiteralContext ctx) {
        List<ASTNode> elements = new ArrayList<>();
        for (var expr : ctx.expression()) {
            elements.add(visit(expr));
        }
        return new ArrayLiteralNode(elements);
    }

    /**
     * Visits an index access context and builds an IndexAccessNode.
     * Handles multi-dimensional access like arr[0][1].
     *
     * @param ctx the index access context from the parse tree
     * @return an IndexAccessNode containing the identifier and all index expressions
     */
    @Override
    public ASTNode visitIndexAccess(RJScriptParser.IndexAccessContext ctx) {
        String identifier = ctx.IDENTIFIER().getText();
        List<ASTNode> indices = new ArrayList<>();
        for (var expr : ctx.expression()) {
            indices.add(visit(expr));
        }
        return new IndexAccessNode(identifier, indices);
    }

    /**
     * Unescapes a string by processing escape sequences like \n, \t, \", \\, etc.
     *
     * @param text the string to unescape
     * @return the unescaped string with escape sequences converted to their actual characters
     */
    private String unescapeString(String text) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            if (c == '\\' && i + 1 < text.length()) {
                char next = text.charAt(i + 1);
                switch (next) {
                    case 'n' -> result.append('\n');
                    case 't' -> result.append('\t');
                    case 'r' -> result.append('\r');
                    case '"' -> result.append('"');
                    case '\\' -> result.append('\\');
                    default -> {
                        result.append(c);
                        result.append(next);
                    }
                }
                i++; // Skip the next character since we processed it
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }
}
